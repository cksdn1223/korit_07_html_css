# color / image 웹페이지 꾸미기
## 배경 꾸미기
### 배경에 그라데이션 넣기
- 그라데이션 : 두 가지 이상의 색을 이용하여 두 색을 점점 변화시켜가며 채색하는 방식.

https://showcases.yalco.kr/html-css/02-08/02.html
1. backround 속성의 속성 값으로 linear-gradient(색1, 색2)
2. linear-gradient(각도(deg), 색1, 색2)
3. linear-gradient(각도,색1,퍼센트값, 색2)
  - 이전까지는 색상이 반반씩 나왔는데, 첫 번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣어줍니다.
4. linear-gradient(색1, 색2, 색3)
  - 참고 : linear-gradient(색1 퍼센트값, 색2 퍼센트값, 색3 퍼센트값)

## 포지셔닝
HTML로 작성한 문서(웹 페이지)는 하나의 기기로만 여는 것이 아니기 때문에 상대적입니다. 따라서 요소의 위치를 잡는 데 포지셔닝이 매우 중요한 역할을 합니다. 그것의 기초가 `<span>`과 `<div>`의 성격 차이였습니다. 그리고 display: inline / block / inline-block

### position 속성
참조
https://showcases.yalco.kr/html-css/02-09/01.html

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지를 설정하는 데 사용.
- `position 속성은 부모 요소의 것이지 자식에게 대물림되지 않음.`

1. static
  - position 속성의 default 값으로 top / left 등의 위치조정을 하더라도 위치이동 X -> HTML 구조를 따르는 것.
2. relative
  - 상대적인, 이라는 의미로 위치이동이 가능.
  - 자신의 HTML 구조 상에서의 위치에서 이동하게 됩니다.
  - 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지가 됨.
    -> 그 결과 가장 상위 div의 범위를 아예 벗어난다고 하더라도 그 자리로 이동하지 않음
3. absolute
  - 절대적인, 이라는 의미로 `첫 부모 요소(static이 아닌 상태로 만나는 상위 HTML구조)`의 속성값을 이용하여 위치 이동이 가능(relative랑 다른 좌표가 필요함)
  - 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 위치 이동을 하는것을 볼 수 있습니다. 위치 이동이 일어나는 이유는 display: inline-block 때문이겠죠.

4. fixed
  - 고정된, 이라는 의미로, 부모 요소가 아니라 뷰포트viewport를 기준으로 위치를 지정함. 그래서 .outer보다 더 위에 있는 브라우저 흰색 부분을 기준으로 하기 때문에 똑같이 .red를 top: 100px; left:100px;을 적용하더라도 위치가 약간 위/왼쪽으로 이동하는겁니다.
  - 뷰포트에 `고정된` 위치를 사용하기 때문에 브라우저의 스크롤링에 영향을 받지 않습니다.
    - 해당 속성을 사용하게 될 경우, 특정 팝업창을 띄웠을 때 스크롤과 상관없이 한 곳에 고정시킬 때 자주 사용하는 속성입니다.

5. sticky
  - 특정 요소가 스크롤로 이동할 수 있는 공간을 top / bottom / left / right / z-index 속성값을 이용하여 지정 가능함.
  - 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링했을 때 따라 내려오는데, 그 부분을 지나게 되면 따라오지 않는 등의 효과를 줄 때 사용함.
  - 부모 요소의  여백에 영향을 받음. 자식 요소의 위치를 고정하더라도 스크롤하면서 부모 요소의 위치를 벗어난다면, 자식 요소는 그 이상 움직이지 못함. 이상을 이유로 sticky는 부모 요소의 안쪽이 아니라 동등 / 바깥쪽 요소에 지정하는 것이 좋습니다.

### z-index 속성

https://showcases.yalco.kr/html-css/02-09/02.html

- static이 아닌 모든 경우에 각 요소들간에 높이 차이를 주게 됨으로써 요소들간의 배치를 효율적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용함.
- z-index의 default 값은 auto로 설정되어있는데, 이는 0을 의미함.
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨.
- 이상을 이유로 광고창 등의 경우 무조건 상위에 있어야하기 때문에 css 파일 확인해보시면 z-index:999; 같은 것도 구경할 수 있습니다.

## flex 레이아웃
- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양합니다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야 했는데, 오늘날 flex 가 나오면서 각종 CSS 기능을 통해 레이아웃을 설정하게 되었습니다.

### 부모에 적용하는 flex
참조
https://showcases.yalco.kr/html-css/02-11/01.html

- 참고 : 부모에 적용하는 속성이라는 것은 부모 관련 CSS 에 작성한다는 뜻 입니다.

참조 사이트를 기준으로 바깥쪽 div에 display: flex; 를 적용했을 때와 display: inline-flex; 를 적용했을 때의 p 태그 위치가 바뀌는 점을 확인할 수 있습니다.

이상의 차이에서 확인할 수 있는 점 :
  1. display: flex; 를 div에 적용했을 경우 block 성질은 그대로 유지된 상태로 flex가 적용됨
    -  그래서 p 태그가 개행된 상태로 출력
  2. display: inline-flex; 를 div에 적용했을 경우 block 성질이 inline으로 바뀌게 되면서 회색 div 영역 이후의 부분에 p 태그의 텍스트가 출력됨.

1. flex-direction 속성
  - 내부의 자식 요소들을 어느 축을 기준으로 정렬할지 결정.
  - default 값은 row(왼쪽부터 차례대로 정렬함)

2. justify-content
  - 메인 축에서 내부 요소를 정렬하는 방식을 결정.
  - default 값은 flex-start : 왼쪽부터 내부 요소 정렬
  - center : 내부요소들을 중앙에 배치함.
  - flex-end : 메인 축의 끝 부분인 오른쪽으로 내부 요소가 정렬됨. 순서는 flex-direction을 따릅니다.
  - space-between : 맨 왼쪽과 오른쪽에 하나씩 배치하고 그 사이에 나머지 요소들을 균등하게 배치
  - space-around : 각 내부 요소의 양쪽에 일정한 크기의 빈 공간을 배치.
  - space-evenly : 모든 빈 공간의 크기를 고르게 지정

3. align-items : 메인축의 수직축에서 내부 요소를 정렬할 방식을 결정함.
  - stretch : align-items의 default값으로 이상의 설명처럼 길게 늘립니다.
  - flex-start : min-width / min-height의 크기 그대로 정렬하는 위치를 왼쪽 상단으로 시작함.
  - center : 중앙 정렬
  - flex-end : 수직 축의 끝 부분인 아래로 정렬

- 참고 : display:flex / flex-direction / align-items 는 대부분 세트로 같이 돌아다님

4. flex-wrap
  - 내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
  - default 값 : no-wrap
  - wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라 여러 줄일 때 사용
  - 페이지 상에서의 효과를 보면 min-width / min-height를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div의 영역을 차지하는 것을 확인할 수 있습니다. 만약에 그게 보기 싫으면 stretch를 flex-start / center / flex-end로 바꾸면 되죠.

5. align-content
  - align-items와 혼동이 일어나기 쉽습니다. align-items의 경우에는 flex-start / center / flex-end 를 적용했을 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위 / 중간 / 아래에서 정렬이 일어납니다.

  - 반면 align-content를 사용했을 경우 공백없이 정렬된 상태에서 위 / 중간 / 아래에 정렬이 일어납니다. 

6. gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(그러니까 자식 div에 margin 적용하는거랑 혼동하기가 쉽습니다.)

### 자식에 적용하는 flex

https://showcases.yalco.kr/html-css/02-11/02.html

1. flex-basis / flex-shrink
  - 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 display: flex; 가 적용되어있어야합니다. 그리고 아까 위에서 말한것 처럼 세트인 flex-direction을 적용해야 합니다.

  - `부모 요소에서 flex-direction: row;`이므로 자식 요소에서의 flex-basis는 row방향으로의 크기를 지정합니다.
  - default 값은 auto;
  - 절대값 / 상대값을 적용할 수 있습니다.

  - 만약에 자식 요소의 flex-basis를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없을 겁니다.
  - 해당 경우에 사용하는 것이 flex-shrink입니다.
  - default 값 : 1
    - 전체 공간이 부족할 경우 해당 내부 요소의 크기가 컨텐츠(여기서는 주황색 div)의 width 또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값

2. flex-grow
  - default 값 : 0 - 기존의 크기를 그대로 유지함
  - 숫자의 크기에 따라 나머지 현제 요소들의 공백 크기의 곱만큼 자기가 커집니다. (커지는 방향은 부모의 flex-direction 설정값에 따름)

## 요소를 감추는 방법
1. 원래 보이던 요소를 투명하게 만드는 방법

2. 요소가 보이지 않으면서 가지고 있는 기능 자체도 날리는 방법 

### CSS에서 요소를 숨기는 세 가지 방법
1. opacity 속성 활용
  - 불투명도를 뜻하며 범위는 0 ~ 1 사이의 값. 0으로 하면 불투명도 0이기 때문에 투명해집니다.
  - 해당 요소를 투명하게 만드는 것이기 때문에 기능은 존재합니다.
  - 예전에 악성 광고 사이트 같은데서 많이 쓰던 방법인데 광고팝업을 opacity: 0; 로 설정해서 클릭하면 광고 페이지로 넘어가게 하는 방식이었습니다.

2. visibility 속성 활용
  - visibility의 속성값 : visible / hidden 두 가지로, hidden일 경우에 숨겨지고 기능도 사라지고 공백이 남겨짐

3. display 속성 활용
  - none : 눈에 안보이고 / 기능 삭제되고 아예 없는게 되기 때문에 뒤에있던것들이 앞으로 밀려온다.

참조
https://showcases.yalco.kr/html-css/02-10/02.html

# CSS 고급기능 ( 최근에는 필수 )
## 반복 및 공통되는 스타일
- CSS를 사용하다보면 여러 페이지에서 같은 코드를 반복해서 사용하는 일이 생깁니다. CSS에서 공통적으로 사용되는 코드를 '모듈화'하여 다른 CSS 파일로 임포트 하는 방법, 그리고 자주 사용하는 속성값을 변수명으로 지정하는 방법

### 다른 CSS 파일을 임포트 하기
형식 :
`@import url(불러올 CSS 파일 경로)`

ch07_applied_style
01_cssimport.html / 01_cssimport.css / 00_shared.css    
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="./01_cssimport.css">
  <title>css import 학습하기</title>
</head>
<body>
  <h1>다른 CSS 파일 import 하기</h1>
  <p>
    <strong>@import</strong>를 사용하면 절대 및 상대경로를 사용하여 <br>
    다른 CSS 파일의 내용을 불러올 수 있습니다. <br>
  </p>
  <p>
    여러 페이지에서 공통적으로 사용되는 스타일들을 특정 파일로 <br>
    분리하여 모듈화하는 것이 가능합니다.
  </p>
  <p class="sr-only">
    이 p 태그는 import된  <i>shared.css</i>의 코드가 적용됩니다.
  </p>
</body>
</html>
```
```css
/* 00_shared.css */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  white-space: nowrap;
  border-width: 0;
}
/* 01_cssimport.css */
/* 외부 CSS 파일 import */
@import url(./00_shared.css);

body {
  margin: 0;
  padding: 24px;
}
```
이상의 결과 화면을 확인했을 때 HTML 문서상에서 .sr-only 클래스명을 사용한 `<p>` 태그 내용이 보이지 않도록 숨겨지는 것을 확인할 수 있습니다. 이는 특정 문단의 내용(혹은 div일 수도 있겠네요. class는 공유 가능하니까)을 감추는 설정이 담긴 shared.css 파일을 @import를 통해서 외부에서 가지고 와서 01_cssimport.css에서 사용했기 때문입니다.

이상처럼 HTML 문서를 사용할 때에 CSS를 적용하는 방식으로
1. inline 방식
2. internal style sheet(내부 스타일 시트) 방식
3. linking style sheet(링킹 스타일 시트) 방식
이제 외부 CSS 를 가지고 오는
4. @import (임포트 방식)
상황에 따라서 선택 가능합니다.

### CSS 변수 사용하기
- 변수(variable) : 특정한 데이터에 이름을 붙이는 것을 의미함

- CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고, 그 앞에 `--` 입력해서 변수임을 표시합니다. 예를 들어서 디자이너와 프론트엔드 개발자 간에 소통하게 될 때 특정 색깔을 브랜드 메인 컬러로 설정했다면, `--color-main`, 그 다음 서브 컬러라면 `--color-sub1`과 같은 식으로 지정하는 겁니다.
가장 작은 폰트 사이즈를 지정한다면 `--font-small`과 같은 방식이 되겠네요.

02_cssvariable.html / 02_cssvariable.css / 00_common.css

`@import url()`를 통해서 _해당 파일의 변수 목록을 참조할 수 있도록 import 문을 작성_

- var() -> 특정 CSS 변수의 데이터값을 불러오는 함수

00_common.css를 확인했을 때, 이하에서 볼 수 있듯이 u 태그에서만 --not-good / --wrong 을 참조하도록 작성되어 있습니다. 즉 i 태그에서는 wavy underline orange; 가 먹히지 않는다는 것입니다.
```css
u {
  --not-good: wavy underline orange;
  --wrong: wavy underline red;
}

.wrong {
  --warn: yellow;
}

/* 
모든 요소에서 사용될 수 있는 변수
*/
:root {
  /* 폰트 사이즈 변수 목록 */
  --font-small: 8px;
  --font-normal: 16px;
  --font-large: 24px;
  --font-x-large: 32px;
  --font-xx-large: 40px;
  --font-xxx-large: 48px;

  /* 폰트 두께 변수 목록 */
  --font-w-normal: 400;
  --font-w-bold: 600;
  --font-w-extrabold: 900;

  /* 페이지 컬러 목록 */
  --color-main: #FF4200;
  --color-sub: #865A55;
  --color-text: #49281C;
}
```
- :root의 의미
  - 어떤 요소가 특정 태그 내에서만 사용되는 것이 아니라 페이지 전체에서 광범위하게 쓰이게 될 경우 사용하는 표현. 가상 클래스를 응용하고, root는 예약어로 전체 페이지를 의미합니다.

이상의 import문과 그 응용, 그리고 CSS 변수의 개념은 특정 페이지들의 합인 웹 서비스 상에서 공통된 요소와 특정한 부분을 나누어 관리하는 것은 다른 사람과의 협업 체제에서 매우 중요한 부분중 하나입니다.


## 벤터 프리픽스
- transition 속성
  1. --webkit-transition과 같은 방식으로 쓰이는데,
    1. -webkit : 사파리 / 크롬 / 오페라
    2. -moz : 파이어폭스
    3. -ms : 엣지 / 익스플로러
    4. -o : 구 버전 오페라

표준이 정립되는 CSS 속성들의 경우에 각 브라우저가 구현하는대로 동작합니다. 즉 사용자마다 서로 다른 UX를 가지게 될 수 있다는 의미입니다.

따라서 아직 표준화되지 않았거나 최신기능이라 사용자의 브라우저가 구버전일 가능성이 있을 때 벤더 프리픽스를 먼저 붙여서 사용하고, 공식 표준 속성은 맨마지막에 작성합니다.

왜냐면 CSS는 '순서대로' 덮어쓰기 때문에 일단 비표준으로 작성한 것이 후에 표준이 있다면 그걸로 덮어쓰기가 자동으로 이루어지기 때문입니다.

# 서체 스타일링
## 서체 및 웹 폰트

### Google Fonts 도입 방법
1. chrome 구글 폰트 검색
2. Noto Sans Korean
  - Noto : No Tofu / 문자가 깨지는 빈 사각형 모양을 Tofu라고 불렀었는데 구글이 만든 안깨지는 글씨체 
  - 모든 언어를 깔끔하게 표시할 수 있는 서체.
  - 너무 보편적이라 브랜드 사용시에는 적용되지 않는 편입니다.


# JavaScript
- 갖다 놓는 HTML / 꾸미는 CSS / 특정 값의 변화등을 시키는 역할 JS

## 발생 배경
- JS는 웹페이지를 _동적으로_ 만들기 위해 탄생한 언어입니다.  사용자가 상호작용을 할 수 있도록 하여 UX에 엄청난 영향을 끼친 언어라고 할 수 있습니다.

## 주요 특징
1. 인터프리어 언어 : Java와 달리 Interpreter에 해당하기 때문에 오류나기 전까지는 실행이 됩니다.
2. 동적 타입(Dynamically Typed) : 변수를 선언할 때 타입을 미리 지정하지 않아도 됩니다. 코드를 실행중에 적당히 보고 나서 type을 결정합니다. Java가 초반에 선언해야 하는 점과 매우 차이가 있습니다.
3. 객체 기반(Object-Based) : 클래스가 없이도 객체를 만들고 사용하는 것이 가능. 거의 모든것이 객체로 취급됩니다 ( 클래스가 없는 )
4. 싱글 스레드(Single Thread) : 한번에 하나의 작업만 순차적으로 처리합니다. 근데 비동기 처리 개념을 통해서 복잡한 작업을 효율적으로 처리하는 것은 가능합니다.
## 장점
1. 웹 브라우저의 기본 언어 : 별도의 설치 없이 모든 웹 브라우저에서 실행됩니다.
2. 유연한 문법 : Java를 배운 저희에게는 너무 자유롭다 싶겠지만 이게 초심자들에게는 장점에 해당합니다.
3. 다양한 활용분야 : 웹 브라우저 외에도 서버(Node.js), 모바일 앱(React Native), 알고리즘
4. 생태계 : NPM(Node Package Manager)라는 패키지 저장소를 통해 수많은 오픈소스 라이브러리와 프레임워크를 활용가능합니다.
  - React는 Js의 프레임워크 중 하나입니다. 
## 단점
1. 보안 : 웹브라우저에서 실행되다보니까 보안관련 설정을 많이 해줘야합니다.(저희는 Springboot를 통해서 해줄 예정입니다.)
2. 느린 속도 : 이건 옛날 얘기
3. 예측 불가능한 오류 : 테스트 해보기 전까지 어떤 오류가 발생할지 짐작하기가 어렵다. - TypeScript로 보완이 가능하다
4. 브라우저 호환성 문제 : 이것도 옛날 문제인데 ES6 나오고 나서는 대충 다 해결됐습니다.

```js
console.log('Hello, javaScript!');
```
이상에서 보면 알 수 있듯이 애는 "" '' 구분 없이 '' 얘로 퉁칩니다.

HTML태그 내에 있는 속성값의 경우에는 "" 를 쓸거고, 
JS 코드와 관련된 부분은 '' 를 쓸겁니다.
























